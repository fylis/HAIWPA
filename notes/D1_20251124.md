# D1 - 24.11.2025

# Prolog

Logic, declarative programming language. It is a set of facts and rules

The computation is initiated by running a **query over the program**.

Turing-complete, general-purpose well-suited for intelligent knowledge-processing applications.

## Syntaxe

Program logic is expressed in terms of relations and the computation is initiated by running a query over these relations.

Relations and queries are constructed using Prolog‚Äôs single data type, the `term`.

Relations are defined by `clauses`.

The Prolog engine tries to find a resolution by negation.

## Data types

Terms are either `atoms`, `numbers`, `variables` or `compound terms` .

### Atom

An **atom** is a symbol name starting with a lower case letter or guarded by quotes

```prolog
x
red
'Taco'
'some atom'
'p(a)'
```

### Numbers

Numbers can be floats or integers

### Variables

Variables are denoted by a string consisting of letters, numbers and underscore characters and beginning with an upper-case letter or underscore.

### Compound term

A mix of `atom` called a `functor` and a number of `arguments` which are again terms.

They are ordinarily written as a functor followed by a comma-separated list of argument terms, which is contained in parentheses. The number of arguments is called the term‚Äôs `arity`.

```prolog
person_friend(zelda,[tom,jim])
```

**Special cases**

- A list is an ordered collection of terms, the values are in between `[` `]` , separated by `,` . like `[tom,jim]`.
- A string is a sequence of characters surrounded by `"quotes"`

## Rules

Prolog programs describe relations, defined by means of clauses. Pure Prolog is restricted to `Horn clauses`.

### Facts

```prolog
Head :- Body.
```

`Head` is `true` if `Body` is `true` .

```prolog
human(socrates).

# equals to

human(socrates) :- true.
```

By default it will be always `true/0`.

Right now, we can use it to ask questions like that.

- *is socrates a human?*

```prolog
?- human(socrates).
Yes
```

- *what things are human?*

```prolog
?- human(X).
X = socrates
```

### Rules

Clauses with bodies are called `rules`.

Example

```prolog
mortal(X) :- human(X).
```

- *what things are mortals*

```prolog
?- mortal(X)
X = socrates
```

## Predicates and programs

A `predicate` (or procedure definition) is a collection of clauses whose heads have the same name and arity.

A *logic program is a set of predicates.*

Here‚Äôs an example of family relations.

```prolog
mother_child(trude, sally).

father_chilld(tom, sally)
father_child(tom, erica).
father_child(mike, tom).

sibling(X, Y) :- parent_child(Z, X), parent_child(Z, Y), not(X = Y).

parent_child(X, Y) :- father_child(X, Y).
parent_child(X, Y) :- mother_child(X, Y).
```

The `sibling(X, Y)` function is working like that : 

1. `parent_child(Z, X)`

There exists a person `Z` who is parent of `X`

1. `parent_child(Z, Y)`

The same person `Z` is the parent of `Y`

1. `not(X = Y)`

X and Y must be different people.

**Result**

X and Y are siblings if there exists a parent Z who is the parent of both X and Y, and X is no the same person as Y.

## Loops and recursion

Is it possible to use recursion to find if a person is an ancestor of other.

```prolog
ancestor(X, Y) :- parent_child(X, Y).
ancestor(X, Y) :- parent_child(X, Z), ancestor(Z, Y).
```

It expresses that X is an ancestor of Y if X is parent of Y or X is parent of an ancestor of Y.

## Execution

When we run a Prolog program, we give it **one query (something we want to prove)**

Them, Prolog looks at the rules and facts to see whether the query logically follows from them.

If it can prove the query:

- it returny true
- and it gives any needed variable bindings

```prolog
X = tom
```

If it cannot prove it:

- it returns false

### SLD Resolution

The idea behind : Prolog tries rules one by one and attempts to satisfy all goals.

### üî¢ Multi choice and backtracking

If more than one rule matches a goal, Prolog:

1. Creates a **choice-point**
2. Tries the first rule
3. If something fails later, it goes **back** (backtracking)
4. Tries the next rule

It is called `chronological backtracking` .

For example, the next query will enumerate all valid answers on backtracking.

```prolog
?- father_child(Father, Child)
```

## Negation

To use negation, we have to use `\+`

```prolog
legal(X) :- \+ illegal(X).
```

It means that `X` is legal if Prolog cannot prove that `X`  is illegal.

### ‚ö†Ô∏è Warning

`\+ illegal(apple).` ‚Üí safe

`\+ illegal(X).`  ‚Üí unsafe (X is a variable)

### Why?

```prolog
legal(X) :- \+ illegal(X).
```

If we ask

```prolog
?- legal(X).
```

Prolog will try:

1. For some unknown, prove `\+ illegal(X)`
2. But `illegal(X)` cannot be proven, because X is unknown ‚Üí it fails by default
3. So `\+ illegal(X)` succeeds immediately, making everything appear legal

---

# Programming in Prolog

Loading code = `consulting`

If there is no solution, Prolog writes `no`. If a solution exists then it is printed.

If there are multiple solutions to the query, then these can be requested by entering a semi_colon `;`

```prolog
# SWI-Prolog
?- write('Hello world!'), nl.
Hello World!
true.

?-
```

There is a difference if we write | ?- or ?- (yes instead of true, no instead of false)

---